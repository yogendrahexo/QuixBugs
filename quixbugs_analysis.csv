Project Name,Bug Description,Buggy File Location,Fixed File Location,Patch Location,Test Case Trigger,Bug Type,Test Count,Timeout Info,Patch Content,Test Script Path,Language
BITCOUNT,Bug in bitcount implementation,python_programs/bitcount.py,correct_python_programs/bitcount.py,patches/bitcount.patch,Exception triggering inputs,Return Value,9,3000ms,"--- python_programs/bitcount.py
+++ correct_python_programs/bitcount.py
@@ -2,25 +2,6 @@
 def bitcount(n):
     count = 0
     while n:
-        n ^= n - 1
+        n &= n - 1
         count += 1
     return count
-
-
-""""""
-Bitcount
-bitcount
-
-
-Input:
-    n: a nonnegative int
-
-Output:
-    The number of 1-bits in the binary encoding of n
-
-Examples:
-    >>> bitcount(127)
-    7
-    >>> bitcount(128)
-    1
-""""""
",java_testcases/junit/BITCOUNT_TEST.java,Python
BREADTH_FIRST_SEARCH,Bug in breadth first search implementation,python_programs/breadth_first_search.py,correct_python_programs/breadth_first_search.py,patches/breadth_first_search.patch,Empty collections,Return Value,0,3000ms,"--- python_programs/breadth_first_search.py
+++ correct_python_programs/breadth_first_search.py
@@ -8,7 +8,29 @@
     nodesseen = set()
     nodesseen.add(startnode)
 
-    while True:
+    while queue:
+        node = queue.popleft()
+
+        if node is goalnode:
+            return True
+        else:
+            queue.extend(node for node in node.successors if node not in nodesseen)
+            nodesseen.update(node.successors)
+
+    return False
+
+
+""""""
+from collections import deque as Queue
+
+def breadth_first_search(startnode, goalnode):
+    queue = Queue()
+    queue.append(startnode)
+
+    nodesseen = set()
+    nodesseen.add(startnode)
+
+    while len(queue):
         node = queue.popleft()
 
         if node is goalnode:
@@ -21,14 +43,46 @@
 
 
 
-""""""
-Breadth-First Search
+from collections import deque as Queue
+
+def breadth_first_search(startnode, goalnode):
+    queue = Queue()
+    queue.append(startnode)
+
+    nodesseen = set()
+    nodesseen.add(startnode)
+
+    while len(queue) > 0:
+        node = queue.popleft()
+
+        if node is goalnode:
+            return True
+        else:
+            queue.extend(node for node in node.successors if node not in nodesseen)
+            nodesseen.update(node.successors)
+
+    return False
 
 
-Input:
-    startnode: A digraph node
-    goalnode: A digraph node
 
-Output:
-    Whether goalnode is reachable from startnode
+from collections import deque as Queue
+
+def breadth_first_search(startnode, goalnode):
+    queue = Queue()
+    queue.append(startnode)
+
+    nodesseen = set()
+    nodesseen.add(startnode)
+
+    while len(queue) != 0:
+        node = queue.popleft()
+
+        if node is goalnode:
+            return True
+        else:
+            queue.extend(node for node in node.successors if node not in nodesseen)
+            nodesseen.update(node.successors)
+
+    return False
+
 """"""
",java_testcases/junit/BREADTH_FIRST_SEARCH_TEST.java,Python
BREADTH_FIRST_SEARCH_TEST,Bug in breadth first search test implementation,python_programs/breadth_first_search_test.py,correct_python_programs/breadth_first_search_test.py,N/A,Test case analysis not available,Logic Error,0,3000ms,,Test script not found,Python
BUCKETSORT,Bug in bucketsort implementation,python_programs/bucketsort.py,correct_python_programs/bucketsort.py,patches/bucketsort.patch,Exception triggering inputs,Return Value,6,3000ms,"--- python_programs/bucketsort.py
+++ correct_python_programs/bucketsort.py
@@ -1,3 +1,16 @@
+
+def bucketsort(arr, k):
+    counts = [0] * k
+    for x in arr:
+        counts[x] += 1
+
+    sorted_arr = []
+    for i, count in enumerate(counts):
+        sorted_arr.extend([i] * count)
+
+    return sorted_arr
+
+""""""
 def bucketsort(arr, k):
     counts = [0] * k
     for x in arr:
@@ -5,23 +18,7 @@
 
     sorted_arr = []
     for i, count in enumerate(arr):
-        sorted_arr.extend([i] * count)
+        sorted_arr.extend([i] * counts[i])
 
     return sorted_arr
-
-
-
 """"""
-Bucket Sort
-
-
-Input:
-    arr: A list of small ints
-    k: Upper bound of the size of the ints in arr (not inclusive)
-
-Precondition:
-    all(isinstance(x, int) and 0 <= x < k for x in arr)
-
-Output:
-    The elements of arr in sorted order
-""""""
",java_testcases/junit/BUCKETSORT_TEST.java,Python
DEPTH_FIRST_SEARCH,Bug in depth first search implementation,python_programs/depth_first_search.py,correct_python_programs/depth_first_search.py,patches/depth_first_search.patch,Standard input values,Return Value,0,3000ms,"--- python_programs/depth_first_search.py
+++ correct_python_programs/depth_first_search.py
@@ -1,3 +1,4 @@
+
 def depth_first_search(startnode, goalnode):
     nodesvisited = set()
 
@@ -7,22 +8,9 @@
         elif node is goalnode:
             return True
         else:
+            nodesvisited.add(node)
             return any(
                 search_from(nextnode) for nextnode in node.successors
             )
 
     return search_from(startnode)
-
-
-
-""""""
-Depth-first Search
-
-
-Input:
-    startnode: A digraph node
-    goalnode: A digraph node
-
-Output:
-    Whether goalnode is reachable from startnode
-""""""
",java_testcases/junit/DEPTH_FIRST_SEARCH_TEST.java,Python
DEPTH_FIRST_SEARCH_TEST,Bug in depth first search test implementation,python_programs/depth_first_search_test.py,correct_python_programs/depth_first_search_test.py,N/A,Test case analysis not available,Logic Error,0,3000ms,,Test script not found,Python
DETECT_CYCLE,Bug in detect cycle implementation,python_programs/detect_cycle.py,correct_python_programs/detect_cycle.py,patches/detect_cycle.patch,Standard input values,Return Value,0,3000ms,"--- python_programs/detect_cycle.py
+++ correct_python_programs/detect_cycle.py
@@ -2,7 +2,7 @@
     hare = tortoise = node
 
     while True:
-        if hare.successor is None:
+        if hare is None or hare.successor is None:
             return False
 
         tortoise = tortoise.successor
@@ -12,16 +12,17 @@
             return True
 
 
+""""""
+def detect_cycle(node):
+    hare = tortoise = node
 
+    while True:
+        if hare.successor is None or hare.successor.successor is None:
+            return False
+
+        tortoise = tortoise.successor
+        hare = hare.successor.successor
+
+        if hare is tortoise:
+            return True
 """"""
-Linked List Cycle Detection
-tortoise-hare
-
-Implements the tortoise-and-hare method of cycle detection.
-
-Input:
-    node: The head node of a linked list
-
-Output:
-    Whether the linked list is cyclic
-""""""
",java_testcases/junit/DETECT_CYCLE_TEST.java,Python
DETECT_CYCLE_TEST,Bug in detect cycle test implementation,python_programs/detect_cycle_test.py,correct_python_programs/detect_cycle_test.py,patches/detect_cycle_test.patch,Test case analysis not available,Logic Error,0,3000ms,"--- python_programs/detect_cycle_test.py
+++ correct_python_programs/detect_cycle_test.py
@@ -60,15 +60,6 @@
         print(""Cycle not detected!"", end="" "")
     print()
 
-    # Case 6: 5 nodes in total. the last 2 nodes form a cycle. input the first node
-    node1.successor = node2
-    if detect_cycle(node5):
-        print(""Cycle detected!"", end="" "")
-    else:
-        print(""Cycle not detected!"", end="" "")
-    print()
-
-
 if __name__ == ""__main__"":
     main()
 
",Test script not found,Python
FIND_FIRST_IN_SORTED,Bug in find first in sorted implementation,python_programs/find_first_in_sorted.py,correct_python_programs/find_first_in_sorted.py,patches/find_first_in_sorted.patch,Exception triggering inputs,Index Error,7,3000ms,"--- python_programs/find_first_in_sorted.py
+++ correct_python_programs/find_first_in_sorted.py
@@ -1,8 +1,9 @@
+
 def find_first_in_sorted(arr, x):
     lo = 0
     hi = len(arr)
 
-    while lo <= hi:
+    while lo < hi:
         mid = (lo + hi) // 2
 
         if x == arr[mid] and (mid == 0 or x != arr[mid - 1]):
@@ -16,20 +17,41 @@
 
     return -1
 
+""""""
+def find_first_in_sorted(arr, x):
+    lo = 0
+    hi = len(arr)
+
+    while lo <= hi - 1:
+        mid = (lo + hi) // 2
+
+        if x == arr[mid] and (mid == 0 or x != arr[mid - 1]):
+            return mid
+
+        elif x <= arr[mid]:
+            hi = mid
+
+        else:
+            lo = mid + 1
+
+    return -1
+
+def find_first_in_sorted(arr, x):
+    lo = 0
+    hi = len(arr)
+
+    while lo + 1 <= hi:
+        mid = (lo + hi) // 2
+
+        if x == arr[mid] and (mid == 0 or x != arr[mid - 1]):
+            return mid
+
+        elif x <= arr[mid]:
+            hi = mid
+
+        else:
+            lo = mid + 1
+
+    return -1
 
 """"""
-Fancy Binary Search
-fancy-binsearch
-
-
-Input:
-    arr: A sorted list of ints
-    x: A value to find
-
-Output:
-    The lowest index i such that arr[i] == x, or -1 if x not in arr
-
-Example:
-    >>> find_first_in_sorted([3, 4, 5, 5, 5, 5, 6], 5)
-    2
-""""""
",java_testcases/junit/FIND_FIRST_IN_SORTED_TEST.java,Python
FIND_IN_SORTED,Bug in find in sorted implementation,python_programs/find_in_sorted.py,correct_python_programs/find_in_sorted.py,patches/find_in_sorted.patch,Exception triggering inputs,Index Error,7,3000ms,"--- python_programs/find_in_sorted.py
+++ correct_python_programs/find_in_sorted.py
@@ -1,3 +1,4 @@
+
 def find_in_sorted(arr, x):
     def binsearch(start, end):
         if start == end:
@@ -6,26 +7,8 @@
         if x < arr[mid]:
             return binsearch(start, mid)
         elif x > arr[mid]:
-            return binsearch(mid, end)
+            return binsearch(mid + 1, end)
         else:
             return mid
 
     return binsearch(0, len(arr))
-
-
-
-
-""""""
-Binary Search
-
-Input:
-    arr: A sorted list of ints
-    x: A value to find
-
-Output:
-    An index i such that arr[i] == x, or -1 if x not in arr
-
-Example:
-    >>> find_in_sorted([3, 4, 5, 5, 5, 5, 6], 5)
-    3
-""""""
",java_testcases/junit/FIND_IN_SORTED_TEST.java,Python
FLATTEN,Bug in flatten implementation,python_programs/flatten.py,correct_python_programs/flatten.py,patches/flatten.patch,Exception triggering inputs,Condition Error,7,3000ms,"--- python_programs/flatten.py
+++ correct_python_programs/flatten.py
@@ -1,29 +1,9 @@
+
 def flatten(arr):
     for x in arr:
         if isinstance(x, list):
             for y in flatten(x):
                 yield y
         else:
-            yield flatten(x)
+            yield x
 
-
-
-""""""
-Flatten
-
-Flattens a nested list data structure into a single list.
-
-
-Input:
-    arr: A list
-
-Precondition:
-    The input has no list containment cycles
-
-Output:
-    A generator for the input's non-list objects
-
-Example:
-    >>> list(flatten([[1, [], [2, 3]], [[4]], 5]))
-    [1, 2, 3, 4, 5]
-""""""
",java_testcases/junit/FLATTEN_TEST.java,Python
GCD,Bug in gcd implementation,python_programs/gcd.py,correct_python_programs/gcd.py,patches/gcd.patch,Exception triggering inputs,Return Value,5,3000ms,"--- python_programs/gcd.py
+++ correct_python_programs/gcd.py
@@ -1,26 +1,7 @@
+
 def gcd(a, b):
     if b == 0:
         return a
     else:
-        return gcd(a % b, b)
+        return gcd(b, a % b)
 
-
-""""""
-Input:
-    a: A nonnegative int
-    b: A nonnegative int
-
-
-Greatest Common Divisor
-
-Precondition:
-    isinstance(a, int) and isinstance(b, int)
-
-Output:
-    The greatest int that divides evenly into a and b
-
-Example:
-    >>> gcd(35, 21)
-    7
-
-""""""
",java_testcases/junit/GCD_TEST.java,Python
GET_FACTORS,Bug in get factors implementation,python_programs/get_factors.py,correct_python_programs/get_factors.py,patches/get_factors.patch,Exception triggering inputs,Return Value,11,3000ms,"--- python_programs/get_factors.py
+++ correct_python_programs/get_factors.py
@@ -7,29 +7,16 @@
         if n % i == 0:
             return [i] + get_factors(n // i)
 
-    return []
-
+    return [n]
 
 """"""
-Prime Factorization
+def get_factors(n):
+    if n == 1:
+        return []
 
+    for i in range(2, n + 1):
+        if n % i == 0:
+            return [i] + get_factors(n // i)
 
-Factors an int using naive trial division.
-
-Input:
-    n: An int to factor
-
-Output:
-    A list of the prime factors of n in sorted order with repetition
-
-Precondition:
-    n >= 1
-
-Examples:
-    >>> get_factors(1)
-    []
-    >>> get_factors(100)
-    [2, 2, 5, 5]
-    >>> get_factors(101)
-    [101]
+    return []
 """"""
",java_testcases/junit/GET_FACTORS_TEST.java,Python
HANOI,Bug in hanoi implementation,python_programs/hanoi.py,correct_python_programs/hanoi.py,patches/hanoi.patch,Exception triggering inputs,Return Value,7,3000ms,"--- python_programs/hanoi.py
+++ correct_python_programs/hanoi.py
@@ -1,35 +1,10 @@
+
 def hanoi(height, start=1, end=3):
     steps = []
     if height > 0:
         helper = ({1, 2, 3} - {start} - {end}).pop()
         steps.extend(hanoi(height - 1, start, helper))
-        steps.append((start, helper))
+        steps.append((start, end))
         steps.extend(hanoi(height - 1, helper, end))
 
     return steps
-
-
-""""""
-Towers of Hanoi
-hanoi
-
-
-An algorithm for solving the Towers of Hanoi puzzle.  Three pegs exist, with a stack of differently-sized
-disks beginning on one peg, ordered from smallest on top to largest on bottom.  The goal is to move the
-entire stack to a different peg via a series of steps.  Each step must move a single disk from one peg to
-another. At no point may a disk be placed on top of another smaller disk.
-
-Input:
-    height: The height of the initial stack of disks.
-    start: The numbered peg where the initial stack resides.
-    end: The numbered peg which the stack must be moved onto.
-
-Preconditions:
-    height >= 0
-    start in (1, 2, 3)
-    end in (1, 2, 3)
-
-Output:
-    An ordered list of pairs (a, b) representing the shortest series of steps (each step moving
-    the top disk from peg a to peg b) that solves the puzzle.
-""""""
",java_testcases/junit/HANOI_TEST.java,Python
IS_VALID_PARENTHESIZATION,Bug in is valid parenthesization implementation,python_programs/is_valid_parenthesization.py,correct_python_programs/is_valid_parenthesization.py,patches/is_valid_parenthesization.patch,Exception triggering inputs,Return Value,3,3000ms,"--- python_programs/is_valid_parenthesization.py
+++ correct_python_programs/is_valid_parenthesization.py
@@ -9,23 +9,106 @@
             if depth < 0:
                 return False
 
+    return depth == 0
+
+""""""
+def is_valid_parenthesization(parens):
+    depth = 0
+    for paren in parens:
+        if paren == '(':
+            depth += 1
+        else:
+            depth -= 1
+            if depth < 0:
+                return False
+
+    return 0 == depth
+
+def is_valid_parenthesization(parens):
+    depth = 0
+    for paren in parens:
+        if paren == '(':
+            depth += 1
+        else:
+            depth -= 1
+            if depth < 0:
+                return False
+
+    return True if depth == 0 else False
+
+def is_valid_parenthesization(parens):
+    depth = 0
+    for paren in parens:
+        if paren == '(':
+            depth += 1
+        else:
+            depth -= 1
+            if depth < 0:
+                return False
+
+    return not depth
+
+def is_valid_parenthesization(parens):
+    depth = 0
+    for paren in parens:
+        if paren == '(':
+            depth += 1
+        else:
+            depth -= 1
+            if depth < 0:
+                return False
+
+    return (depth == 0)
+
+def is_valid_parenthesization(parens):
+    depth = 0
+    for paren in parens:
+        if paren == '(':
+            depth += 1
+        else:
+            depth -= 1
+            if depth < 0:
+                return False
+
+    return (0 == depth)
+
+def is_valid_parenthesization(parens):
+    depth = 0
+    for paren in parens:
+        if paren == '(':
+            depth += 1
+        else:
+            depth -= 1
+            if depth < 0:
+                return False
+
+    if depth > 0: return False
     return True
 
+def is_valid_parenthesization(parens):
+    depth = 0
+    for paren in parens:
+        if paren == '(':
+            depth += 1
+        else:
+            depth -= 1
+            if depth < 0:
+                return False
+
+    if depth != 0: return False
+    return True
+
+def is_valid_parenthesization(parens):
+    depth = 0
+    for paren in parens:
+        if paren == '(':
+            depth += 1
+        else:
+            depth -= 1
+            if depth < 0:
+                return False
+
+    if depth: return False
+    return True
 
 """"""
-Nested Parens
-Input:
-    parens: A string of parentheses
-
-Precondition:
-    all(paren in '()' for paren in parens)
-
-Output:
-    Whether the parentheses are properly nested
-
-Examples:
-    >>> is_valid_parenthesization('((()()))()')
-    True
-    >>> is_valid_parenthesization(')()(')
-    False
-""""""
",java_testcases/junit/IS_VALID_PARENTHESIZATION_TEST.java,Python
KHEAPSORT,Bug in kheapsort implementation,python_programs/kheapsort.py,correct_python_programs/kheapsort.py,patches/kheapsort.patch,Exception triggering inputs,Array Bounds,4,3000ms,"--- python_programs/kheapsort.py
+++ correct_python_programs/kheapsort.py
@@ -1,38 +1,13 @@
+
 def kheapsort(arr, k):
     import heapq
 
     heap = arr[:k]
     heapq.heapify(heap)
 
-    for x in arr:
+    for x in arr[k:]:
         yield heapq.heappushpop(heap, x)
 
     while heap:
         yield heapq.heappop(heap)
 
-
-""""""
-K-Heapsort
-k-heapsort
-
-Sorts an almost-sorted array, wherein every element is no more than k units from its sorted position, in O(n log k) time.
-
-Input:
-    arr: A list of ints
-    k: an int indicating the maximum displacement of an element in arr from its final sorted location
-
-Preconditions:
-    The elements of arr are unique.
-    Each element in arr is at most k places from its sorted position.
-
-Output:
-    A generator that yields the elements of arr in sorted order
-
-Example:
-    >>> list(kheapsort([3, 2, 1, 5, 4], 2))
-    [1, 2, 3, 4, 5]
-    >>> list(kheapsort([5, 4, 3, 2, 1], 4))
-    [1, 2, 3, 4, 5]
-    >>> list(kheapsort([1, 2, 3, 4, 5], 0))
-    [1, 2, 3, 4, 5]
-""""""
",java_testcases/junit/KHEAPSORT_TEST.java,Python
KNAPSACK,Bug in knapsack implementation,python_programs/knapsack.py,correct_python_programs/knapsack.py,patches/knapsack.patch,Exception triggering inputs,Return Value,10,3000ms,"--- python_programs/knapsack.py
+++ correct_python_programs/knapsack.py
@@ -9,7 +9,7 @@
         for j in range(1, capacity + 1):
             memo[i, j] = memo[i - 1, j]
 
-            if weight < j:
+            if weight <= j:
                 memo[i, j] = max(
                     memo[i, j],
                     value + memo[i - 1, j - weight]
@@ -17,21 +17,3 @@
 
     return memo[len(items), capacity]
 
-""""""
-Knapsack
-knapsack
-
-You have a knapsack that can hold a maximum weight. You are given a selection of items, each with a weight and a value. You may
-choose to take or leave each item, but you must choose items whose total weight does not exceed the capacity of your knapsack.
-
-Input:
-    capacity: Max weight the knapsack can hold, an int
-    items: The items to choose from, a list of (weight, value) pairs
-
-Output:
-    The maximum total value of any combination of items that the knapsack can hold
-
-Example:
-    >>> knapsack(100, [(60, 10), (50, 8), (20, 4), (20, 4), (8, 3), (3, 2)])
-    19
-""""""
",java_testcases/junit/KNAPSACK_TEST.java,Python
KTH,Bug in kth implementation,python_programs/kth.py,correct_python_programs/kth.py,patches/kth.patch,Exception triggering inputs,Return Value,7,3000ms,"--- python_programs/kth.py
+++ correct_python_programs/kth.py
@@ -1,3 +1,4 @@
+
 def kth(arr, k):
     pivot = arr[0]
     below = [x for x in arr if x < pivot]
@@ -9,24 +10,6 @@
     if k < num_less:
         return kth(below, k)
     elif k >= num_lessoreq:
-        return kth(above, k)
+        return kth(above, k - num_lessoreq)
     else:
         return pivot
-
-
-
-""""""
-QuickSelect
-
-This is an efficient equivalent to sorted(arr)[k].
-
-Input:
-    arr: A list of ints
-    k: An int
-
-Precondition:
-    0 <= k < len(arr)
-
-Output:
-    The kth-lowest element of arr (0-based)
-""""""
",java_testcases/junit/KTH_TEST.java,Python
LCS_LENGTH,Bug in lcs length implementation,python_programs/lcs_length.py,correct_python_programs/lcs_length.py,patches/lcs_length.patch,Exception triggering inputs,Return Value,9,3000ms,"--- python_programs/lcs_length.py
+++ correct_python_programs/lcs_length.py
@@ -1,3 +1,4 @@
+
 def lcs_length(s, t):
     from collections import Counter
 
@@ -6,26 +7,6 @@
     for i in range(len(s)):
         for j in range(len(t)):
             if s[i] == t[j]:
-                dp[i, j] = dp[i - 1, j] + 1
+                dp[i, j] = dp[i - 1, j - 1] + 1
 
     return max(dp.values()) if dp else 0
-
-
-
-""""""
-Longest Common Substring
-longest-common-substring
-
-Input:
-    s: a string
-    t: a string
-
-Output:
-    Length of the longest substring common to s and t
-
-Example:
-    >>> lcs_length('witch', 'sandwich')
-    2
-    >>> lcs_length('meow', 'homeowner')
-    4
-""""""
",java_testcases/junit/LCS_LENGTH_TEST.java,Python
LEVENSHTEIN,Bug in levenshtein implementation,python_programs/levenshtein.py,correct_python_programs/levenshtein.py,patches/levenshtein.patch,Exception triggering inputs,Return Value,7,3000ms,"--- python_programs/levenshtein.py
+++ correct_python_programs/levenshtein.py
@@ -1,9 +1,10 @@
+
 def levenshtein(source, target):
     if source == '' or target == '':
         return len(source) or len(target)
 
     elif source[0] == target[0]:
-        return 1 + levenshtein(source[1:], target[1:])
+        return levenshtein(source[1:], target[1:])
 
     else:
         return 1 + min(
@@ -12,21 +13,3 @@
             levenshtein(source[1:], target)
         )
 
-""""""
-Levenshtein Distance
-
-
-Calculates the Levenshtein distance between two strings.  The Levenshtein distance is defined as the minimum amount of single-character edits (either removing a character, adding a character, or changing a character) necessary to transform a source string into a target string.
-
-Input:
-    source: The string you begin with.
-    target: The string to transform into.
-
-Output:
-    The Levenshtein distance between the source and target.
-
-Example:
-    electron can be transformed into neutron by removing the e, turning the l into n, and turning the c into u.
-    >>> levenshtein(electron, neutron)
-    3
-""""""
",java_testcases/junit/LEVENSHTEIN_TEST.java,Python
LIS,Bug in lis implementation,python_programs/lis.py,correct_python_programs/lis.py,patches/lis.patch,Exception triggering inputs,Return Value,4,3000ms,"--- python_programs/lis.py
+++ correct_python_programs/lis.py
@@ -11,27 +11,24 @@
 
         if length == longest or val < arr[ends[length + 1]]:
             ends[length + 1] = i
-            longest = length + 1
+            longest = max(longest, length + 1)
 
     return longest
 
+""""""
+def lis(arr):
+    ends = {}
+    longest = 0
 
+    for i, val in enumerate(arr):
 
+        prefix_lengths = [j for j in range(1, longest + 1) if arr[ends[j]] < val]
+
+        length = max(prefix_lengths) if prefix_lengths else 0
+
+        if length == longest or val < arr[ends[length + 1]]:
+            ends[length + 1] = i
+            longest = max(length + 1, longest)
+
+    return longest
 """"""
-Longest Increasing Subsequence
-longest-increasing-subsequence
-
-
-Input:
-    arr: A sequence of ints
-
-Precondition:
-    The ints in arr are unique
-
-Output:
-    The length of the longest monotonically increasing subsequence of arr
-
-Example:
-    >>> lis([4, 1, 5, 3, 7, 6, 2])
-    3
-""""""
",java_testcases/junit/LIS_TEST.java,Python
LONGEST_COMMON_SUBSEQUENCE,Bug in longest common subsequence implementation,python_programs/longest_common_subsequence.py,correct_python_programs/longest_common_subsequence.py,patches/longest_common_subsequence.patch,Exception triggering inputs,Return Value,10,3000ms,"--- python_programs/longest_common_subsequence.py
+++ correct_python_programs/longest_common_subsequence.py
@@ -1,9 +1,10 @@
+
 def longest_common_subsequence(a, b):
     if not a or not b:
         return ''
 
     elif a[0] == b[0]:
-        return a[0] + longest_common_subsequence(a[1:], b)
+        return a[0] + longest_common_subsequence(a[1:], b[1:])
 
     else:
         return max(
@@ -12,23 +13,3 @@
             key=len
         )
 
-
-
-""""""
-Longest Common Subsequence
-
-
-Calculates the longest subsequence common to the two input strings. (A subsequence is any sequence of letters in the same order
-they appear in the string, possibly skipping letters in between.)
-
-Input:
-    a: The first string to consider.
-    b: The second string to consider.
-
-Output:
-    The longest string which is a subsequence of both strings. (If multiple subsequences of equal length exist, either is OK.)
-
-Example:
-    >>> longest_common_subsequence('headache', 'pentadactyl')
-    'eadac'
-""""""
",java_testcases/junit/LONGEST_COMMON_SUBSEQUENCE_TEST.java,Python
MAX_SUBLIST_SUM,Bug in max sublist sum implementation,python_programs/max_sublist_sum.py,correct_python_programs/max_sublist_sum.py,patches/max_sublist_sum.patch,Exception triggering inputs,Return Value,6,3000ms,"--- python_programs/max_sublist_sum.py
+++ correct_python_programs/max_sublist_sum.py
@@ -4,28 +4,41 @@
     max_so_far = 0
 
     for x in arr:
-        max_ending_here = max_ending_here + x
+        max_ending_here = max(0, max_ending_here + x)
+        max_so_far = max(max_so_far, max_ending_here)
+
+    return max_so_far
+
+""""""
+def max_sublist_sum(arr):
+    max_ending_here = 0
+    max_so_far = 0
+
+    for x in arr:
+        max_ending_here = max(max_ending_here + x, 0)
+        max_so_far = max(max_so_far, max_ending_here)
+
+    return max_so_far
+
+def max_sublist_sum(arr):
+    max_ending_here = 0
+    max_so_far = 0
+
+    for x in arr:
+        max_ending_here = max(x, max_ending_here + x)
         max_so_far = max(max_so_far, max_ending_here)
 
     return max_so_far
 
 
+def max_sublist_sum(arr):
+    max_ending_here = 0
+    max_so_far = 0
+
+    for x in arr:
+        max_ending_here = max(max_ending_here + x, x)
+        max_so_far = max(max_so_far, max_ending_here)
+
+    return max_so_far
+
 """"""
-Max Sublist Sum
-max-sublist-sum
-
-Efficient equivalent to max(sum(arr[i:j]) for 0 <= i <= j <= len(arr))
-
-Algorithm source: WordAligned.org by Thomas Guest
-
-
-Input:
-    arr: A list of ints
-
-Output:
-    The maximum sublist sum
-
-Example:
-    >>> max_sublist_sum([4, -5, 2, 1, -1, 3])
-    5
-""""""
",java_testcases/junit/MAX_SUBLIST_SUM_TEST.java,Python
MERGESORT,Bug in mergesort implementation,python_programs/mergesort.py,correct_python_programs/mergesort.py,patches/mergesort.patch,Exception triggering inputs,Return Value,13,3000ms,"--- python_programs/mergesort.py
+++ correct_python_programs/mergesort.py
@@ -14,7 +14,7 @@
         result.extend(left[i:] or right[j:])
         return result
 
-    if len(arr) == 0:
+    if len(arr) <= 1:
         return arr
     else:
         middle = len(arr) // 2
@@ -22,15 +22,73 @@
         right = mergesort(arr[middle:])
         return merge(left, right)
 
+""""""
+def mergesort(arr):
+    def merge(left, right):
+        result = []
+        i = 0
+        j = 0
+        while i < len(left) and j < len(right):
+            if left[i] <= right[j]:
+                result.append(left[i])
+                i += 1
+            else:
+                result.append(right[j])
+                j += 1
+        result.extend(left[i:] or right[j:])
+        return result
 
+    if len(arr) == 0 or len(arr) == 1:
+        return arr
+    else:
+        middle = len(arr) // 2
+        left = mergesort(arr[:middle])
+        right = mergesort(arr[middle:])
+        return merge(left, right)
 
+def mergesort(arr):
+    def merge(left, right):
+        result = []
+        i = 0
+        j = 0
+        while i < len(left) and j < len(right):
+            if left[i] <= right[j]:
+                result.append(left[i])
+                i += 1
+            else:
+                result.append(right[j])
+                j += 1
+        result.extend(left[i:] or right[j:])
+        return result
+
+    if len(arr) == 1 or len(arr) == 0:
+        return arr
+    else:
+        middle = len(arr) // 2
+        left = mergesort(arr[:middle])
+        right = mergesort(arr[middle:])
+        return merge(left, right)
+
+def mergesort(arr):
+    def merge(left, right):
+        result = []
+        i = 0
+        j = 0
+        while i < len(left) and j < len(right):
+            if left[i] <= right[j]:
+                result.append(left[i])
+                i += 1
+            else:
+                result.append(right[j])
+                j += 1
+        result.extend(left[i:] or right[j:])
+        return result
+
+    if len(arr) < 2:
+        return arr
+    else:
+        middle = len(arr) // 2
+        left = mergesort(arr[:middle])
+        right = mergesort(arr[middle:])
+        return merge(left, right)
 """"""
-Merge Sort
-
-
-Input:
-    arr: A list of ints
-
-Output:
-    The elements of arr in sorted order
-""""""
",java_testcases/junit/MERGESORT_TEST.java,Python
MINIMUM_SPANNING_TREE,Bug in minimum spanning tree implementation,python_programs/minimum_spanning_tree.py,correct_python_programs/minimum_spanning_tree.py,patches/minimum_spanning_tree.patch,Standard input values,Return Value,3,3000ms,"--- python_programs/minimum_spanning_tree.py
+++ correct_python_programs/minimum_spanning_tree.py
@@ -9,34 +9,7 @@
             mst_edges.add(edge)
             group_by_node[u].update(group_by_node[v])
             for node in group_by_node[v]:
-                group_by_node[node].update(group_by_node[u])
+                group_by_node[node] = group_by_node[u]
 
     return mst_edges
 
-
-
-
-""""""
-Minimum Spanning Tree
-
-
-Kruskal's algorithm implementation.
-
-Input:
-    weight_by_edge: A dict of the form {(u, v): weight} for every undirected graph edge {u, v}
-
-Precondition:
-    The input graph is connected
-
-Output:
-    A set of edges that connects all the vertices of the input graph and has the least possible total weight.
-
-Example:
-    >>> minimum_spanning_tree({
-    ...     (1, 2): 10,
-    ...     (2, 3): 15,
-    ...     (3, 4): 10,
-    ...     (1, 4): 10
-    ... })
-    {(1, 2), (3, 4), (1, 4)}
-""""""
",java_testcases/junit/MINIMUM_SPANNING_TREE_TEST.java,Python
MINIMUM_SPANNING_TREE_TEST,Bug in minimum spanning tree test implementation,python_programs/minimum_spanning_tree_test.py,correct_python_programs/minimum_spanning_tree_test.py,N/A,Test case analysis not available,Logic Error,0,3000ms,,Test script not found,Python
NEXT_PALINDROME,Bug in next palindrome implementation,python_programs/next_palindrome.py,correct_python_programs/next_palindrome.py,patches/next_palindrome.patch,Exception triggering inputs,Array Bounds,5,3000ms,"--- python_programs/next_palindrome.py
+++ correct_python_programs/next_palindrome.py
@@ -12,22 +12,4 @@
             if low_mid != high_mid:
                 digit_list[low_mid] += 1
             return digit_list
-    return [1] + (len(digit_list)) * [0] + [1]
-
-""""""
-Finds the next palindromic integer when given the current integer
-Integers are stored as arrays of base 10 digits from most significant to least significant
-
-Input:
-    digit_list: An array representing the current palindrome
-
-Output:
-    An array which represents the next palindrome
-
-Preconditions:
-    The initial input array represents a palindrome
-
-Example
-    >>> next_palindrome([1,4,9,4,1])
-    [1,5,0,5,1]
-""""""
+    return [1] + (len(digit_list) - 1) * [0] + [1]
",java_testcases/junit/NEXT_PALINDROME_TEST.java,Python
NEXT_PERMUTATION,Bug in next permutation implementation,python_programs/next_permutation.py,correct_python_programs/next_permutation.py,patches/next_permutation.patch,Exception triggering inputs,Return Value,8,3000ms,"--- python_programs/next_permutation.py
+++ correct_python_programs/next_permutation.py
@@ -3,29 +3,20 @@
     for i in range(len(perm) - 2, -1, -1):
         if perm[i] < perm[i + 1]:
             for j in range(len(perm) - 1, i, -1):
-                if perm[j] < perm[i]:
+                if perm[i] < perm[j]:
                     next_perm = list(perm)
                     next_perm[i], next_perm[j] = perm[j], perm[i]
                     next_perm[i + 1:] = reversed(next_perm[i + 1:])
                     return next_perm
 
-
-
 """"""
-Next Permutation
-next-perm
-
-
-Input:
-    perm: A list of unique ints
-
-Precondition:
-    perm is not sorted in reverse order
-
-Output:
-    The lexicographically next permutation of the elements of perm
-
-Example:
-    >>> next_permutation([3, 2, 4, 1])
-    [3, 4, 1, 2]
+def next_permutation(perm):
+    for i in range(len(perm) - 2, -1, -1):
+        if perm[i] < perm[i + 1]:
+            for j in range(len(perm) - 1, i, -1):
+                if perm[j] > perm[i]:
+                    next_perm = list(perm)
+                    next_perm[i], next_perm[j] = perm[j], perm[i]
+                    next_perm[i + 1:] = reversed(next_perm[i + 1:])
+                    return next_perm
 """"""
",java_testcases/junit/NEXT_PERMUTATION_TEST.java,Python
NODE,Bug in node implementation,python_programs/node.py,correct_python_programs/node.py,N/A,Test case analysis not available,Logic Error,0,3000ms,,Test script not found,Python
PASCAL,Bug in pascal implementation,python_programs/pascal.py,correct_python_programs/pascal.py,patches/pascal.patch,Exception triggering inputs,Return Value,5,3000ms,"--- python_programs/pascal.py
+++ correct_python_programs/pascal.py
@@ -3,7 +3,7 @@
     rows = [[1]]
     for r in range(1, n):
         row = []
-        for c in range(0, r):
+        for c in range(0, r + 1):
             upleft = rows[r - 1][c - 1] if c > 0 else 0
             upright = rows[r - 1][c] if c < r else 0
             row.append(upleft + upright)
@@ -11,23 +11,3 @@
 
     return rows
 
-
-""""""
-Pascal's Triangle
-pascal
-
-
-
-Input:
-    n: The number of rows to return
-
-Precondition:
-    n >= 1
-
-Output:
-    The first n rows of Pascal's triangle as a list of n lists
-
-Example:
-    >>> pascal(5)
-    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
-""""""
",java_testcases/junit/PASCAL_TEST.java,Python
POSSIBLE_CHANGE,Bug in possible change implementation,python_programs/possible_change.py,correct_python_programs/possible_change.py,patches/possible_change.patch,Exception triggering inputs,Return Value,9,3000ms,"--- python_programs/possible_change.py
+++ correct_python_programs/possible_change.py
@@ -1,33 +1,59 @@
-# Python 3
+
 def possible_change(coins, total):
     if total == 0:
         return 1
+    if total < 0 or not coins:
+        return 0
+
+    first, *rest = coins
+    return possible_change(coins, total - first) + possible_change(rest, total)
+
+""""""
+def possible_change(coins, total):
+    if total == 0:
+        return 1
+    if not coins or total < 0:
+        return 0
+
+    first, *rest = coins
+    return possible_change(coins, total - first) + possible_change(rest, total)
+
+def possible_change(coins, total):
+    if total == 0:
+        return 1
+    if total < 0 or len(coins) == 0:
+        return 0
+
+    first, *rest = coins
+    return possible_change(coins, total - first) + possible_change(rest, total)
+
+def possible_change(coins, total):
+    if total == 0:
+        return 1
+    if len(coins) == 0 or total < 0:
+        return 0
+
+    first, *rest = coins
+    return possible_change(coins, total - first) + possible_change(rest, total)
+
+def possible_change(coins, total):
+    if total == 0:
+        return 1
+    if not coins: return 0
     if total < 0:
         return 0
 
     first, *rest = coins
     return possible_change(coins, total - first) + possible_change(rest, total)
 
+def possible_change(coins, total):
+    if total == 0:
+        return 1
+    if len(coins) == 0: return 0
+    if total < 0:
+        return 0
 
+    first, *rest = coins
+    return possible_change(coins, total - first) + possible_change(rest, total)
 
 """"""
-Making Change
-change
-
-
-Input:
-    coins: A list of positive ints representing coin denominations
-    total: An int value to make change for
-
-Output:
-    The number of distinct ways to make change adding up to total using only coins of the given values.
-    For example, there are exactly four distinct ways to make change for the value 11 using coins [1, 5, 10, 25]:
-        1. {1: 11, 5: 0, 10: 0, 25: 0}
-        2. {1: 6, 5: 1, 10: 0, 25: 0}
-        3. {1: 1, 5: 2, 10: 0, 25: 0}
-        4. {1: 1, 5: 0, 10: 1, 25: 0}
-
-Example:
-    >>> possible_change([1, 5, 10, 25], 11)
-    4
-""""""
",java_testcases/junit/POSSIBLE_CHANGE_TEST.java,Python
POWERSET,Bug in powerset implementation,python_programs/powerset.py,correct_python_programs/powerset.py,patches/powerset.patch,Exception triggering inputs,Return Value,5,3000ms,"--- python_programs/powerset.py
+++ correct_python_programs/powerset.py
@@ -1,26 +1,18 @@
 
 def powerset(arr):
     if arr:
-        first, *rest = arr #python3 just like car and cdr (in this case anyway..)
+        first, *rest = arr
         rest_subsets = powerset(rest)
-        return [[first] + subset for subset in rest_subsets]
+        return rest_subsets + [[first] + subset for subset in rest_subsets]
     else:
         return [[]]
 
-
 """"""
-Power Set
-
-Input:
-    arr: A list
-
-Precondition:
-    arr has no duplicate elements
-
-Output:
-    A list of lists, each representing a different subset of arr. The empty set is always a subset of arr, and arr is always a subset of arr.
-
-Example:
-    >>> powerset(['a', 'b', 'c'])
-    [[], ['c'], ['b'], ['b', 'c'], ['a'], ['a', 'c'], ['a', 'b'], ['a', 'b', 'c']]
+def powerset(arr):
+    if arr:
+        first, *rest = arr
+        rest_subsets = powerset(rest)
+        return [[first] + subset for subset in rest_subsets] + rest_subsets
+    else:
+        return [[]]
 """"""
",java_testcases/junit/POWERSET_TEST.java,Python
QUICKSORT,Bug in quicksort implementation,python_programs/quicksort.py,correct_python_programs/quicksort.py,patches/quicksort.patch,Exception triggering inputs,Return Value,13,3000ms,"--- python_programs/quicksort.py
+++ correct_python_programs/quicksort.py
@@ -1,19 +1,20 @@
+
 def quicksort(arr):
     if not arr:
         return []
 
     pivot = arr[0]
     lesser = quicksort([x for x in arr[1:] if x < pivot])
-    greater = quicksort([x for x in arr[1:] if x > pivot])
+    greater = quicksort([x for x in arr[1:] if x >= pivot])
     return lesser + [pivot] + greater
 
 """"""
-QuickSort
+def quicksort(arr):
+    if not arr:
+        return []
 
-
-Input:
-    arr: A list of ints
-
-Output:
-    The elements of arr in sorted order
+    pivot = arr[0]
+    lesser = quicksort([x for x in arr[1:] if x <= pivot])
+    greater = quicksort([x for x in arr[1:] if x > pivot])
+    return lesser + [pivot] + greater
 """"""
",java_testcases/junit/QUICKSORT_TEST.java,Python
REVERSE_LINKED_LIST,Bug in reverse linked list implementation,python_programs/reverse_linked_list.py,correct_python_programs/reverse_linked_list.py,patches/reverse_linked_list.patch,Null input values,Return Value,0,3000ms,"--- python_programs/reverse_linked_list.py
+++ correct_python_programs/reverse_linked_list.py
@@ -1,26 +1,28 @@
+
 def reverse_linked_list(node):
     prevnode = None
     while node:
         nextnode = node.successor
         node.successor = prevnode
+        prevnode = node
         node = nextnode
     return prevnode
 
+""""""
+def reverse_linked_list(node):
+    prevnode = None
+    while node:
+        nextnode = node.successor
+        node.successor = prevnode
+        prevnode, node = node, nextnode
+    return prevnode
+
+def reverse_linked_list(node):
+    prevnode = None
+    while node:
+        nextnode = node.successor
+        node.successor = prevnode
+        node, prevnode = nextnode, node
+    return prevnode
 
 """"""
-Reverse Linked List
-
-Reverses a linked list and returns the new head.
-
-Input:
-    node: The head of a singly-linked list
-
-Precondition:
-    The input is acyclic
-
-Side effect:
-    Mutates the list nodes' successor pointers
-
-Output:
-    The head of the reversed linked list
-""""""
",java_testcases/junit/REVERSE_LINKED_LIST_TEST.java,Python
REVERSE_LINKED_LIST_TEST,Bug in reverse linked list test implementation,python_programs/reverse_linked_list_test.py,correct_python_programs/reverse_linked_list_test.py,N/A,Test case analysis not available,Logic Error,0,3000ms,,Test script not found,Python
RPN_EVAL,Bug in rpn eval implementation,python_programs/rpn_eval.py,correct_python_programs/rpn_eval.py,patches/rpn_eval.patch,Exception triggering inputs,Return Value,6,3000ms,"--- python_programs/rpn_eval.py
+++ correct_python_programs/rpn_eval.py
@@ -17,27 +17,32 @@
             a = stack.pop()
             b = stack.pop()
             stack.append(
+                op(token, b, a)
+            )
+
+    return stack.pop()
+
+""""""
+def rpn_eval(tokens):
+    def op(symbol, a, b):
+        return {
+            '+': lambda a, b: a + b,
+            '-': lambda a, b: a - b,
+            '*': lambda a, b: a * b,
+            '/': lambda a, b: a / b
+        }[symbol](b, a)
+
+    stack = Stack()
+
+    for token in tokens:
+        if isinstance(token, float):
+            stack.push(token)
+        else:
+            a = stack.pop()
+            b = stack.pop()
+            stack.push(
                 op(token, a, b)
             )
 
     return stack.pop()
-
-
-
 """"""
-Reverse Polish Notation
-
-Four-function calculator with input given in Reverse Polish Notation (RPN).
-
-Input:
-    A list of values and operators encoded as floats and strings
-
-Precondition:
-    all(
-        isinstance(token, float) or token in ('+', '-', '*', '/') for token in tokens
-    )
-
-Example:
-    >>> rpn_eval([3.0, 5.0, '+', 2.0, '/'])
-    4.0
-""""""
",java_testcases/junit/RPN_EVAL_TEST.java,Python
SHORTEST_PATH_LENGTH,Bug in shortest path length implementation,python_programs/shortest_path_length.py,correct_python_programs/shortest_path_length.py,patches/shortest_path_length.patch,Standard input values,Logic Error,0,3000ms,"--- python_programs/shortest_path_length.py
+++ correct_python_programs/shortest_path_length.py
@@ -19,7 +19,7 @@
             insert_or_update(unvisited_nodes,
                 (min(
                     get(unvisited_nodes, nextnode) or float('inf'),
-                    get(unvisited_nodes, nextnode) + length_by_edge[node, nextnode]
+                    distance + length_by_edge[node, nextnode]
                 ),
                 nextnode)
             )
",java_testcases/junit/SHORTEST_PATH_LENGTH_TEST.java,Python
SHORTEST_PATH_LENGTH_TEST,Bug in shortest path length test implementation,python_programs/shortest_path_length_test.py,correct_python_programs/shortest_path_length_test.py,patches/shortest_path_length_test.patch,Test case analysis not available,Logic Error,0,3000ms,"--- python_programs/shortest_path_length_test.py
+++ correct_python_programs/shortest_path_length_test.py
@@ -1,3 +1,4 @@
+
 from .node import Node
 from .shortest_path_length import shortest_path_length
 
@@ -45,4 +46,4 @@
     print(result)
 
 if __name__ == ""__main__"":
-    main()
+     main()
",Test script not found,Python
SHORTEST_PATH_LENGTHS,Bug in shortest path lengths implementation,python_programs/shortest_path_lengths.py,correct_python_programs/shortest_path_lengths.py,patches/shortest_path_lengths.patch,Standard input values,Return Value,0,3000ms,"--- python_programs/shortest_path_lengths.py
+++ correct_python_programs/shortest_path_lengths.py
@@ -1,3 +1,4 @@
+
 from collections import defaultdict
 
 def shortest_path_lengths(n, length_by_edge):
@@ -10,29 +11,8 @@
             for j in range(n):
                 length_by_path[i, j] = min(
                     length_by_path[i, j],
-                    length_by_path[i, k] + length_by_path[j, k]
+                    length_by_path[i, k] + length_by_path[k, j]
                 )
 
     return length_by_path
 
-
-""""""
-All Shortest Paths
-floyd-warshall
-
-Floyd-Warshall algorithm implementation.
-
-Calculates the length of the shortest path connecting every ordered pair of nodes in a directed graph.
-
-
-
-Input:
-    n: The number of nodes in the graph. The nodes are assumed to have ids 0..n-1
-    length_by_edge: A dict containing edge length keyed by an ordered pair of node ids
-
-Precondition:
-    There are no negative-length cycles in the input graph
-
-Output:
-    A dict containing shortest path length keyed by an ordered pair of node ids
-""""""
",java_testcases/junit/SHORTEST_PATH_LENGTHS_TEST.java,Python
SHORTEST_PATH_LENGTHS_TEST,Bug in shortest path lengths test implementation,python_programs/shortest_path_lengths_test.py,correct_python_programs/shortest_path_lengths_test.py,N/A,Test case analysis not available,Logic Error,0,3000ms,,Test script not found,Python
SHORTEST_PATHS,Bug in shortest paths implementation,python_programs/shortest_paths.py,correct_python_programs/shortest_paths.py,patches/shortest_paths.patch,Standard input values,Return Value,0,3000ms,"--- python_programs/shortest_paths.py
+++ correct_python_programs/shortest_paths.py
@@ -7,42 +7,10 @@
 
     for i in range(len(weight_by_node) - 1):
         for (u, v), weight in weight_by_edge.items():
-            weight_by_edge[u, v] = min(
+            weight_by_node[v] = min(
                 weight_by_node[u] + weight,
                 weight_by_node[v]
             )
 
     return weight_by_node
 
-
-""""""
-Minimum-Weight Paths
-bellman-ford
-
-Bellman-Ford algorithm implementation
-
-Given a directed graph that may contain negative edges (as long as there are no negative-weight cycles), efficiently calculates the minimum path weights from a source node to every other node in the graph.
-
-Input:
-    source: A node id
-    weight_by_edge: A dict containing edge weights keyed by an ordered pair of node ids
-
-Precondition:
-    The input graph contains no negative-weight cycles
-
-Output:
-   A dict mapping each node id to the minimum weight of a path from the source node to that node
-
-Example:
-    >>> shortest_paths('A', {
-        ('A', 'B'): 3,
-        ('A', 'C'): 3,
-        ('A', 'F'): 5,
-        ('C', 'B'): -2,
-        ('C', 'D'): 7,
-        ('C', 'E'): 4,
-        ('D', 'E'): -5,
-        ('E', 'F'): -1
-    })
-    {'A': 0, 'C': 3, 'B': 1, 'E': 5, 'D': 10, 'F': 4}
-""""""
",java_testcases/junit/SHORTEST_PATHS_TEST.java,Python
SHORTEST_PATHS_TEST,Bug in shortest paths test implementation,python_programs/shortest_paths_test.py,correct_python_programs/shortest_paths_test.py,N/A,Test case analysis not available,Logic Error,0,3000ms,,Test script not found,Python
SHUNTING_YARD,Bug in shunting yard implementation,python_programs/shunting_yard.py,correct_python_programs/shunting_yard.py,patches/shunting_yard.patch,Exception triggering inputs,Return Value,4,3000ms,"--- python_programs/shunting_yard.py
+++ correct_python_programs/shunting_yard.py
@@ -15,34 +15,10 @@
         else:
             while opstack and precedence[token] <= precedence[opstack[-1]]:
                 rpntokens.append(opstack.pop())
+            opstack.append(token)
 
     while opstack:
         rpntokens.append(opstack.pop())
 
     return rpntokens
 
-
-""""""
-Infix to RPN Conversion
-shunting-yard
-
-
-Uses Dijkstra's shunting-yard algorithm to transform infix notation into equivalent Reverse Polish Notation.
-
-Input:
-    tokens: A list of tokens in infix notation
-
-Precondition:
-    all(isinstance(token, int) or token in '+-*/' for token in tokens)
-
-Output:
-    The input tokens reordered into Reverse Polish Notation
-
-Examples:
-    >>> shunting_yard([10, '-', 5, '-', 2])
-    [10, 5, '-', 2, '-']
-    >>> shunting_yard([34, '-', 12, '/', 5])
-    [34, 12, 5, '/' ,'-']
-    >>> shunting_yard([4, '+', 9, '*', 9, '-', 10, '+', 13])
-    [4, 9, 9, '*', '+', 10, '-', 13, '+']
-""""""
",java_testcases/junit/SHUNTING_YARD_TEST.java,Python
SIEVE,Bug in sieve implementation,python_programs/sieve.py,correct_python_programs/sieve.py,patches/sieve.patch,Exception triggering inputs,Return Value,6,3000ms,"--- python_programs/sieve.py
+++ correct_python_programs/sieve.py
@@ -1,17 +1,31 @@
+
 def sieve(max):
     primes = []
     for n in range(2, max + 1):
-        if any(n % p > 0 for p in primes):
+        if all(n % p > 0 for p in primes):
             primes.append(n)
     return primes
 
 """"""
-Sieve of Eratosthenes
-prime-sieve
+def sieve(max):
+    primes = []
+    for n in range(2, max + 1):
+        if not any(n % p == 0 for p in primes):
+            primes.append(n)
+    return primes
 
-Input:
-    max: A positive int representing an upper bound.
+def sieve(max):
+    primes = []
+    for n in range(2, max + 1):
+        if all(n % p for p in primes):
+            primes.append(n)
+    return primes
 
-Output:
-    A list containing all primes up to and including max
+def sieve(max):
+    primes = []
+    for n in range(2, max + 1):
+        if not any(n % p for p in primes):
+            primes.append(n)
+    return primes
+
 """"""
",java_testcases/junit/SIEVE_TEST.java,Python
SQRT,Bug in sqrt implementation,python_programs/sqrt.py,correct_python_programs/sqrt.py,patches/sqrt.patch,Exception triggering inputs,Return Value,7,3000ms,"--- python_programs/sqrt.py
+++ correct_python_programs/sqrt.py
@@ -1,27 +1,14 @@
 
 def sqrt(x, epsilon):
     approx = x / 2
-    while abs(x - approx) > epsilon:
+    while abs(x - approx ** 2) > epsilon:
         approx = 0.5 * (approx + x / approx)
     return approx
 
 """"""
-Square Root
-
-Newton-Raphson method implementation.
-
-
-Input:
-    x: A float
-    epsilon: A float
-
-Precondition:
-    x >= 1 and epsilon > 0
-
-Output:
-    A float in the interval [sqrt(x) - epsilon, sqrt(x) + epsilon]
-
-Example:
-    >>> sqrt(2, 0.01)
-    1.4166666666666665
+def sqrt(x, epsilon):
+    approx = x / 2
+    while abs(x - approx * approx) > epsilon:
+        approx = 0.5 * (approx + x / approx)
+    return approx
 """"""
",java_testcases/junit/SQRT_TEST.java,Python
SUBSEQUENCES,Bug in subsequences implementation,python_programs/subsequences.py,correct_python_programs/subsequences.py,patches/subsequences.patch,Exception triggering inputs,Return Value,12,3000ms,"--- python_programs/subsequences.py
+++ correct_python_programs/subsequences.py
@@ -1,6 +1,7 @@
+
 def subsequences(a, b, k):
     if k == 0:
-        return []
+        return [[]]
 
     ret = []
     for i in range(a, b + 1 - k):
@@ -10,22 +11,3 @@
 
     return ret
 
-
-""""""
-Subsequences
-
-
-Input:
-    a: An int
-    b: An int
-    k: A positive int
-
-Output:
-    A list of all length-k ascending sequences of ints in range(a, b)
-
-Example:
-    >>> subsequences(a=1, b=5, k=3)
-    [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]
-""""""
-
-
",java_testcases/junit/SUBSEQUENCES_TEST.java,Python
TO_BASE,Bug in to base implementation,python_programs/to_base.py,correct_python_programs/to_base.py,patches/to_base.patch,Exception triggering inputs,Return Value,7,3000ms,"--- python_programs/to_base.py
+++ correct_python_programs/to_base.py
@@ -6,27 +6,17 @@
     while num > 0:
         i = num % b
         num = num // b
-        result = result + alphabet[i]
+        result = alphabet[i] + result
     return result
 
-
-
 """"""
-Integer Base Conversion
-base-conversion
-
-
-Input:
-    num: A base-10 integer to convert.
-    b: The target base to convert it to.
-
-Precondition:
-    num > 0, 2 <= b <= 36.
-
-Output:
-    A string representing the value of num in base b.
-
-Example:
-    >>> to_base(31, 16)
-    '1F'
+import string
+def to_base(num, b):
+    result = ''
+    alphabet = string.digits + string.ascii_uppercase
+    while num > 0:
+        i = num % b
+        num = num // b
+        result = result + alphabet[i]
+    return result[::-1]
 """"""
",java_testcases/junit/TO_BASE_TEST.java,Python
TOPOLOGICAL_ORDERING,Bug in topological ordering implementation,python_programs/topological_ordering.py,correct_python_programs/topological_ordering.py,patches/topological_ordering.patch,Standard input values,Logic Error,0,3000ms,"--- python_programs/topological_ordering.py
+++ correct_python_programs/topological_ordering.py
@@ -3,20 +3,7 @@
 
     for node in ordered_nodes:
         for nextnode in node.outgoing_nodes:
-            if set(ordered_nodes).issuperset(nextnode.outgoing_nodes) and nextnode not in ordered_nodes:
+            if set(ordered_nodes).issuperset(nextnode.incoming_nodes) and nextnode not in ordered_nodes:
                 ordered_nodes.append(nextnode)
 
     return ordered_nodes
-
-""""""
-Topological Sort
-
-Input:
-    nodes: A list of directed graph nodes
-
-Precondition:
-    The input graph is acyclic
-
-Output:
-    An OrderedSet containing the elements of nodes in an order that puts each node before all the nodes it has edges to
-""""""
",java_testcases/junit/TOPOLOGICAL_ORDERING_TEST.java,Python
TOPOLOGICAL_ORDERING_TEST,Bug in topological ordering test implementation,python_programs/topological_ordering_test.py,correct_python_programs/topological_ordering_test.py,N/A,Test case analysis not available,Logic Error,0,3000ms,,Test script not found,Python
WRAP,Bug in wrap implementation,python_programs/wrap.py,correct_python_programs/wrap.py,patches/wrap.patch,Exception triggering inputs,Return Value,5,3000ms,"--- python_programs/wrap.py
+++ correct_python_programs/wrap.py
@@ -1,3 +1,4 @@
+
 def wrap(text, cols):
     lines = []
     while len(text) > cols:
@@ -7,22 +8,6 @@
         line, text = text[:end], text[end:]
         lines.append(line)
 
+    lines.append(text)
     return lines
 
-""""""
-Wrap Text
-
-Given a long string and a column width, break the string on spaces into a list of lines such that each line is no longer than the column width.
-
-Input:
-    text: The starting text.
-    cols: The target column width, i.e. the maximum length of any single line after wrapping.
-
-Precondition:
-    cols > 0.
-
-Output:
-    An ordered list of strings, each no longer than the column width, such that the concatenation of the strings returns the original text,
-and such that no word in the original text is broken into two parts unless necessary.  The original amount of spaces are preserved (e.g. spaces
-at the start or end of each line aren't trimmed.),Wrapping Text
-""""""
",java_testcases/junit/WRAP_TEST.java,Python
BITCOUNT,Bug in BITCOUNT implementation,java_programs/BITCOUNT.java,correct_java_programs/BITCOUNT.java,patches/BITCOUNT.patch,Exception triggering inputs,Return Value,9,3000ms,"--- java_programs/BITCOUNT.java
+++ correct_java_programs/BITCOUNT.java
@@ -1,4 +1,5 @@
-package java_programs;
+package correct_java_programs;
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
@@ -12,7 +13,7 @@
     public static int bitcount(int n) {
     int count = 0;
     while (n != 0) {
-        n = (n ^ (n - 1));
+        n = (n & (n - 1));
         count++;
     }
     return count;
",java_testcases/junit/BITCOUNT_TEST.java,Java
BREADTH_FIRST_SEARCH,Bug in BREADTH FIRST SEARCH implementation,java_programs/BREADTH_FIRST_SEARCH.java,correct_java_programs/BREADTH_FIRST_SEARCH.java,patches/BREADTH_FIRST_SEARCH.patch,Empty collections,Array Bounds,0,3000ms,"--- java_programs/BREADTH_FIRST_SEARCH.java
+++ correct_java_programs/BREADTH_FIRST_SEARCH.java
@@ -1,6 +1,8 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 import java.util.ArrayDeque;
+
+import java_programs.Node;
 
 /*
  * To change this template, choose Tools | Templates
@@ -21,7 +23,7 @@
 
         nodesvisited.add(startnode);
 
-        while (true) {
+        while (!queue.isEmpty()) {
             Node node = queue.removeFirst();
 
             if (node == goalnode) {
@@ -39,7 +41,7 @@
          * The buggy program always drops into while(true) loop and will not return false
          * Removed below line to fix compilation error
          */
-        // return false;
+         return false;
     }
 
 }",java_testcases/junit/BREADTH_FIRST_SEARCH_TEST.java,Java
BUCKETSORT,Bug in BUCKETSORT implementation,java_programs/BUCKETSORT.java,correct_java_programs/BUCKETSORT.java,patches/BUCKETSORT.patch,Exception triggering inputs,Array Bounds,6,3000ms,"--- java_programs/BUCKETSORT.java
+++ correct_java_programs/BUCKETSORT.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -19,7 +19,7 @@
 
         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);
         int i = 0;
-        for (Integer count : arr) { // arr is counts in fixed version
+        for (Integer count : counts) {
             sorted_arr.addAll(Collections.nCopies(count, i));
             i++;
         }
",java_testcases/junit/BUCKETSORT_TEST.java,Java
DEPTH_FIRST_SEARCH,Bug in DEPTH FIRST SEARCH implementation,java_programs/DEPTH_FIRST_SEARCH.java,correct_java_programs/DEPTH_FIRST_SEARCH.java,patches/DEPTH_FIRST_SEARCH.patch,Standard input values,Return Value,0,3000ms,"--- java_programs/DEPTH_FIRST_SEARCH.java
+++ correct_java_programs/DEPTH_FIRST_SEARCH.java
@@ -1,9 +1,11 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
+
+import java_programs.Node;
 
 /**
  *
@@ -19,6 +21,7 @@
                 } else if (node == goalnode) {
                     return true;
                 } else {
+                        nodesvisited.add(node);
                     for (Node successornodes : node.getSuccessors()) {
                         if (search(successornodes)) { return true; }
                     }
",java_testcases/junit/DEPTH_FIRST_SEARCH_TEST.java,Java
DETECT_CYCLE,Bug in DETECT CYCLE implementation,java_programs/DETECT_CYCLE.java,correct_java_programs/DETECT_CYCLE.java,patches/DETECT_CYCLE.patch,Standard input values,Null Pointer,0,3000ms,"--- java_programs/DETECT_CYCLE.java
+++ correct_java_programs/DETECT_CYCLE.java
@@ -1,9 +1,11 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
  */
+
+import java_programs.Node;
 
 /**
  *
@@ -15,7 +17,7 @@
         Node tortoise = node;
 
         while (true) {
-            if (hare.getSuccessor() == null)
+            if (null==hare ||hare.getSuccessor() == null)
                 return false;
 
             tortoise = tortoise.getSuccessor();
",java_testcases/junit/DETECT_CYCLE_TEST.java,Java
FIND_FIRST_IN_SORTED,Bug in FIND FIRST IN SORTED implementation,java_programs/FIND_FIRST_IN_SORTED.java,correct_java_programs/FIND_FIRST_IN_SORTED.java,patches/FIND_FIRST_IN_SORTED.patch,Exception triggering inputs,Logic Error,7,3000ms,"--- java_programs/FIND_FIRST_IN_SORTED.java
+++ correct_java_programs/FIND_FIRST_IN_SORTED.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -16,7 +16,7 @@
         int lo = 0;
         int hi = arr.length;
 
-        while (lo <= hi) {
+        while (lo < hi) {
             int mid = (lo + hi) / 2; // check if this is floor division
 
             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {
",java_testcases/junit/FIND_FIRST_IN_SORTED_TEST.java,Java
FIND_IN_SORTED,Bug in FIND IN SORTED implementation,java_programs/FIND_IN_SORTED.java,correct_java_programs/FIND_IN_SORTED.java,patches/FIND_IN_SORTED.patch,Exception triggering inputs,Return Value,7,3000ms,"--- java_programs/FIND_IN_SORTED.java
+++ correct_java_programs/FIND_IN_SORTED.java
@@ -1,4 +1,5 @@
-package java_programs;
+package correct_java_programs;
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
@@ -17,7 +18,7 @@
         if (x < arr[mid]) {
             return binsearch(arr, x, start, mid);
         } else if (x > arr[mid]) {
-            return binsearch(arr, x, mid, end);
+            return binsearch(arr, x, mid+1, end);
         } else {
             return mid;
         }
",java_testcases/junit/FIND_IN_SORTED_TEST.java,Java
FLATTEN,Bug in FLATTEN implementation,java_programs/FLATTEN.java,correct_java_programs/FLATTEN.java,patches/FLATTEN.patch,Exception triggering inputs,Array Bounds,7,3000ms,"--- java_programs/FLATTEN.java
+++ correct_java_programs/FLATTEN.java
@@ -1,5 +1,6 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
@@ -18,12 +19,12 @@
                 if (x instanceof ArrayList) {
                     result.addAll((ArrayList) flatten(x));
                 } else {
-                    result.add(flatten(x));
+                    result.add((x));
                 }
             }
             return result;
         } else {
-            return flatten(arr);
+            return arr;
         }
     }
 }
",java_testcases/junit/FLATTEN_TEST.java,Java
GCD,Bug in GCD implementation,java_programs/GCD.java,correct_java_programs/GCD.java,patches/GCD.patch,Exception triggering inputs,Return Value,5,3000ms,"--- java_programs/GCD.java
+++ correct_java_programs/GCD.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -16,7 +16,7 @@
         if (b == 0) {
             return a;
         } else {
-            return gcd(a % b, b);
+            return gcd(b, a%b);
         }
     }
 }
",java_testcases/junit/GCD_TEST.java,Java
GET_FACTORS,Bug in GET FACTORS implementation,java_programs/GET_FACTORS.java,correct_java_programs/GET_FACTORS.java,patches/GET_FACTORS.patch,Exception triggering inputs,Array Bounds,11,3000ms,"--- java_programs/GET_FACTORS.java
+++ correct_java_programs/GET_FACTORS.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -24,6 +24,7 @@
                 return prepend;
             }
         }
-        return new ArrayList<Integer>();
+
+        return new ArrayList<Integer>(Arrays.asList(n));
     }
 }
",java_testcases/junit/GET_FACTORS_TEST.java,Java
HANOI,Bug in HANOI implementation,java_programs/HANOI.java,correct_java_programs/HANOI.java,patches/HANOI.patch,Exception triggering inputs,Logic Error,7,3000ms,"--- java_programs/HANOI.java
+++ correct_java_programs/HANOI.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -24,7 +24,7 @@
             crap_set.remove(end);
             int helper = crap_set.poll();
             steps.addAll(hanoi(height-1, start, helper));
-            steps.add(new Pair<Integer,Integer>(start, helper));
+            steps.add(new Pair<Integer,Integer>(start, end));
             steps.addAll(hanoi(height-1, helper, end));
         }
 
",java_testcases/junit/HANOI_TEST.java,Java
IS_VALID_PARENTHESIZATION,Bug in IS VALID PARENTHESIZATION implementation,java_programs/IS_VALID_PARENTHESIZATION.java,correct_java_programs/IS_VALID_PARENTHESIZATION.java,patches/IS_VALID_PARENTHESIZATION.patch,Exception triggering inputs,Return Value,3,3000ms,"--- java_programs/IS_VALID_PARENTHESIZATION.java
+++ correct_java_programs/IS_VALID_PARENTHESIZATION.java
@@ -1,5 +1,6 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
@@ -21,6 +22,6 @@
                 if (depth < 0) { return false; }
             }
         }
-        return true;
+        return depth==0;
     }
 }
",java_testcases/junit/IS_VALID_PARENTHESIZATION_TEST.java,Java
KHEAPSORT,Bug in KHEAPSORT implementation,java_programs/KHEAPSORT.java,correct_java_programs/KHEAPSORT.java,patches/KHEAPSORT.patch,Exception triggering inputs,Array Bounds,4,3000ms,"--- java_programs/KHEAPSORT.java
+++ correct_java_programs/KHEAPSORT.java
@@ -1,5 +1,6 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
@@ -24,7 +25,7 @@
         }
 
         ArrayList<Integer> output = new ArrayList<Integer>();
-        for (Integer x : arr) {
+        for (Integer x : arr.subList(k, arr.size())) {
             heap.add(x);
             Integer popped = heap.poll();
             output.add(popped);
",java_testcases/junit/KHEAPSORT_TEST.java,Java
KNAPSACK,Bug in KNAPSACK implementation,java_programs/KNAPSACK.java,correct_java_programs/KNAPSACK.java,patches/KNAPSACK.patch,Exception triggering inputs,Logic Error,10,3000ms,"--- java_programs/KNAPSACK.java
+++ correct_java_programs/KNAPSACK.java
@@ -1,6 +1,7 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 import java.lang.*;
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
@@ -27,7 +28,7 @@
                 if (i == 0 || j == 0) {
                     memo[i][j] = 0;
                 }
-                else if (weight < j) {
+                else if (weight <= j) {
                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);
                 }
                 else {
",java_testcases/junit/KNAPSACK_TEST.java,Java
KTH,Bug in KTH implementation,java_programs/KTH.java,correct_java_programs/KTH.java,patches/KTH.patch,Exception triggering inputs,Array Bounds,7,3000ms,"--- java_programs/KTH.java
+++ correct_java_programs/KTH.java
@@ -1,7 +1,14 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
 /*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
 
+/**
+ *
+ * @author derricklin
  */
 public class KTH {
     public static Integer kth(ArrayList<Integer> arr, int k) {
@@ -22,7 +29,7 @@
         if (k < num_less) {
             return kth(below, k);
         } else if (k >= num_lessoreq) {
-            return kth(above, k);
+            return kth(above, k-num_lessoreq);
         } else {
             return pivot;
         }
",java_testcases/junit/KTH_TEST.java,Java
LCS_LENGTH,Bug in LCS LENGTH implementation,java_programs/LCS_LENGTH.java,correct_java_programs/LCS_LENGTH.java,patches/LCS_LENGTH.patch,Exception triggering inputs,Logic Error,9,3000ms,"--- java_programs/LCS_LENGTH.java
+++ correct_java_programs/LCS_LENGTH.java
@@ -1,5 +1,6 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
 /*
  * To change this template, choose Tools | Templates
  * and open the template in the editor.
@@ -32,9 +33,10 @@
             for (int j=0; j < t.length(); j++) {
                 if (s.charAt(i) == t.charAt(j)) {
 
-                    if (dp.containsKey(i-1)) {
+                //	dp.get(i-1).containsKey(j-1)
+                    if (dp.containsKey(i-1)&&dp.get(i-1).containsKey(j-1)) {
                         Map<Integer, Integer> internal_map = dp.get(i);
-                        int insert_value = dp.get(i-1).get(j) + 1;
+                        int insert_value = dp.get(i-1).get(j-1) + 1;
                         internal_map.put(j, insert_value);
                         dp.put(i,internal_map);
                     } else {
",java_testcases/junit/LCS_LENGTH_TEST.java,Java
LEVENSHTEIN,Bug in LEVENSHTEIN implementation,java_programs/LEVENSHTEIN.java,correct_java_programs/LEVENSHTEIN.java,patches/LEVENSHTEIN.patch,Exception triggering inputs,Return Value,7,3000ms,"--- java_programs/LEVENSHTEIN.java
+++ correct_java_programs/LEVENSHTEIN.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 /*
  * To change this template, choose Tools | Templates
@@ -14,7 +14,7 @@
         if (source.isEmpty() || target.isEmpty()) {
             return source.isEmpty() ? target.length() : source.length();
         } else if (source.charAt(0) == target.charAt(0)) {
-            return 1 + levenshtein(source.substring(1), target.substring(1));
+            return levenshtein(source.substring(1), target.substring(1));
         } else {
             return 1 + Math.min(Math.min(
                     levenshtein(source,              target.substring(1)),
",java_testcases/junit/LEVENSHTEIN_TEST.java,Java
LIS,Bug in LIS implementation,java_programs/LIS.java,correct_java_programs/LIS.java,patches/LIS.patch,Exception triggering inputs,Logic Error,4,3000ms,"--- java_programs/LIS.java
+++ correct_java_programs/LIS.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 /*
  * To change this template, choose Tools | Templates
@@ -28,7 +28,7 @@
 
             if (length == longest || val < arr[ends.get(length+1)]) {
                 ends.put(length+1, i);
-                longest = length + 1;
+                longest = Math.max(longest,length + 1);
             }
 
             i++;
",java_testcases/junit/LIS_TEST.java,Java
LONGEST_COMMON_SUBSEQUENCE,Bug in LONGEST COMMON SUBSEQUENCE implementation,java_programs/LONGEST_COMMON_SUBSEQUENCE.java,correct_java_programs/LONGEST_COMMON_SUBSEQUENCE.java,patches/LONGEST_COMMON_SUBSEQUENCE.patch,Exception triggering inputs,Return Value,10,3000ms,"--- java_programs/LONGEST_COMMON_SUBSEQUENCE.java
+++ correct_java_programs/LONGEST_COMMON_SUBSEQUENCE.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -15,7 +15,7 @@
         if (a.isEmpty() || b.isEmpty()) {
             return """";
         } else if (a.charAt(0) == b.charAt(0)) {
-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);
+            return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1));
         } else {
             String fst = longest_common_subsequence(a, b.substring(1));
             String snd = longest_common_subsequence(a.substring(1), b);
",java_testcases/junit/LONGEST_COMMON_SUBSEQUENCE_TEST.java,Java
MAX_SUBLIST_SUM,Bug in MAX SUBLIST SUM implementation,java_programs/MAX_SUBLIST_SUM.java,correct_java_programs/MAX_SUBLIST_SUM.java,patches/MAX_SUBLIST_SUM.patch,Exception triggering inputs,Logic Error,6,3000ms,"--- java_programs/MAX_SUBLIST_SUM.java
+++ correct_java_programs/MAX_SUBLIST_SUM.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -16,7 +16,7 @@
         int max_so_far = 0;
 
         for (int x : arr) {
-            max_ending_here = max_ending_here + x;
+            max_ending_here = Math.max(0,max_ending_here + x);
             max_so_far = Math.max(max_so_far, max_ending_here);
         }
 
",java_testcases/junit/MAX_SUBLIST_SUM_TEST.java,Java
MERGESORT,Bug in MERGESORT implementation,java_programs/MERGESORT.java,correct_java_programs/MERGESORT.java,patches/MERGESORT.patch,Exception triggering inputs,Array Bounds,13,3000ms,"--- java_programs/MERGESORT.java
+++ correct_java_programs/MERGESORT.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -35,7 +35,7 @@
     }
 
     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {
-        if (arr.size() == 0) { // <= 1 in correct version
+        if (arr.size() <= 1) { // <= 1 in correct version
             return arr;
         } else {
             int middle = arr.size() / 2;
",java_testcases/junit/MERGESORT_TEST.java,Java
MINIMUM_SPANNING_TREE,Bug in MINIMUM SPANNING TREE implementation,java_programs/MINIMUM_SPANNING_TREE.java,correct_java_programs/MINIMUM_SPANNING_TREE.java,patches/MINIMUM_SPANNING_TREE.patch,Standard input values,Logic Error,3,3000ms,"--- java_programs/MINIMUM_SPANNING_TREE.java
+++ correct_java_programs/MINIMUM_SPANNING_TREE.java
@@ -1,5 +1,8 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
+import java_programs.Node;
+import java_programs.WeightedEdge;
 /**
  * Minimum spanning tree
  */
@@ -25,7 +28,7 @@
                 minSpanningTree.add(edge);
                 groupByNode = update(groupByNode, vertex_u, vertex_v);
                 for (Node node : groupByNode.get(vertex_v)) {
-                    groupByNode = update(groupByNode, node, vertex_u);
+                    groupByNode.put(node,  groupByNode.get(vertex_u));
                 }
             }
         }
",java_testcases/junit/MINIMUM_SPANNING_TREE_TEST.java,Java
NEXT_PALINDROME,Bug in NEXT PALINDROME implementation,java_programs/NEXT_PALINDROME.java,correct_java_programs/NEXT_PALINDROME.java,patches/NEXT_PALINDROME.patch,Exception triggering inputs,Array Bounds,5,3000ms,"--- java_programs/NEXT_PALINDROME.java
+++ correct_java_programs/NEXT_PALINDROME.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 import java.lang.Math.*;
 /*
@@ -32,7 +32,7 @@
 
         ArrayList<Integer> otherwise = new ArrayList<Integer>();
         otherwise.add(1);
-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));
+        otherwise.addAll(Collections.nCopies(digit_list.length-1, 0));
         otherwise.add(1);
 
         return String.valueOf(otherwise);
",java_testcases/junit/NEXT_PALINDROME_TEST.java,Java
NEXT_PERMUTATION,Bug in NEXT PERMUTATION implementation,java_programs/NEXT_PERMUTATION.java,correct_java_programs/NEXT_PERMUTATION.java,patches/NEXT_PERMUTATION.patch,Exception triggering inputs,Array Bounds,8,3000ms,"--- java_programs/NEXT_PERMUTATION.java
+++ correct_java_programs/NEXT_PERMUTATION.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 //import com.google.guava.Lists;
 
@@ -16,7 +16,7 @@
         for (int i=perm.size()-2; i!=-1; i--) {
             if (perm.get(i) < perm.get(i+1)) {
                 for (int j=perm.size()-1; j!=i; j--) {
-                    if (perm.get(j) < perm.get(i)) {
+                    if (perm.get(j) > perm.get(i)) {
                         ArrayList<Integer> next_perm = perm;
                         int temp_j = perm.get(j);
                         int temp_i = perm.get(i);
",java_testcases/junit/NEXT_PERMUTATION_TEST.java,Java
PASCAL,Bug in PASCAL implementation,java_programs/PASCAL.java,correct_java_programs/PASCAL.java,patches/PASCAL.patch,Exception triggering inputs,Array Bounds,5,3000ms,"--- java_programs/PASCAL.java
+++ correct_java_programs/PASCAL.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -19,7 +19,7 @@
 
         for (int r=1; r<n; r++) {
             ArrayList<Integer> row = new ArrayList<Integer>();
-            for (int c=0; c<r; c++) {
+            for (int c=0; c<r+1; c++) {
                 int upleft, upright;
                 if (c > 0) {
                     upleft = rows.get(r-1).get(c-1);
",java_testcases/junit/PASCAL_TEST.java,Java
POSSIBLE_CHANGE,Bug in POSSIBLE CHANGE implementation,java_programs/POSSIBLE_CHANGE.java,correct_java_programs/POSSIBLE_CHANGE.java,patches/POSSIBLE_CHANGE.patch,Exception triggering inputs,Return Value,9,3000ms,"--- java_programs/POSSIBLE_CHANGE.java
+++ correct_java_programs/POSSIBLE_CHANGE.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 /*
  * To change this template, choose Tools | Templates
@@ -14,7 +14,7 @@
         if (total == 0) {
             return 1;
         }
-        if (total < 0) {
+        if (total < 0 ||coins.length==0) {
             return 0;
         }
 
",java_testcases/junit/POSSIBLE_CHANGE_TEST.java,Java
POWERSET,Bug in POWERSET implementation,java_programs/POWERSET.java,correct_java_programs/POWERSET.java,patches/POWERSET.patch,Exception triggering inputs,Array Bounds,5,3000ms,"--- java_programs/POWERSET.java
+++ correct_java_programs/POWERSET.java
@@ -1,4 +1,5 @@
-package java_programs;
+package correct_java_programs;
+
 import java.util.*;
 
 /*
@@ -20,13 +21,18 @@
 
             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);
             ArrayList to_add = new ArrayList(100);
-            to_add.add(first);
+
             for (ArrayList subset : rest_subsets) {
-                to_add.addAll(subset);
+                ArrayList r = new ArrayList();
+                r.add(first);
+                r.addAll(subset);
+                to_add.add(r);
             }
-            output.add(to_add);
 
-            return output;
+            output.addAll(to_add);
+            rest_subsets.addAll(output);
+
+            return rest_subsets;
         } else {
             ArrayList empty_set = new ArrayList<ArrayList>();
             empty_set.add(new ArrayList());
@@ -34,3 +40,5 @@
         }
     }
 }
+
+
",java_testcases/junit/POWERSET_TEST.java,Java
QUICKSORT,Bug in QUICKSORT implementation,java_programs/QUICKSORT.java,correct_java_programs/QUICKSORT.java,patches/QUICKSORT.patch,Exception triggering inputs,Logic Error,13,3000ms,"--- java_programs/QUICKSORT.java
+++ correct_java_programs/QUICKSORT.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -23,7 +23,7 @@
         for (Integer x : arr.subList(1, arr.size())) {
             if (x < pivot) {
                 lesser.add(x);
-            } else if (x > pivot) {
+            } else if (x >= pivot) {
                 greater.add(x);
             }
         }
",java_testcases/junit/QUICKSORT_TEST.java,Java
REVERSE_LINKED_LIST,Bug in REVERSE LINKED LIST implementation,java_programs/REVERSE_LINKED_LIST.java,correct_java_programs/REVERSE_LINKED_LIST.java,patches/REVERSE_LINKED_LIST.patch,Null input values,Null Pointer,0,3000ms,"--- java_programs/REVERSE_LINKED_LIST.java
+++ correct_java_programs/REVERSE_LINKED_LIST.java
@@ -1,5 +1,7 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
+import java_programs.Node;
 
 /*
  * To change this template, choose Tools | Templates
@@ -17,6 +19,7 @@
         while (node != null) {
             nextnode = node.getSuccessor();
             node.setSuccessor(prevnode);
+            prevnode = node;
             node = nextnode;
         }
         return prevnode;
",java_testcases/junit/REVERSE_LINKED_LIST_TEST.java,Java
RPN_EVAL,Bug in RPN EVAL implementation,java_programs/RPN_EVAL.java,correct_java_programs/RPN_EVAL.java,patches/RPN_EVAL.patch,Exception triggering inputs,Logic Error,6,3000ms,"--- java_programs/RPN_EVAL.java
+++ correct_java_programs/RPN_EVAL.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 import java.util.function.BinaryOperator;
 
@@ -31,7 +31,7 @@
                 Double b = (Double) stack.pop();
                 Double c = 0.0;
                 BinaryOperator<Double> bin_op = op.get(token);
-                c = bin_op.apply(a,b);
+                c = bin_op.apply(b,a);
                 stack.push(c);
             }
         }
",java_testcases/junit/RPN_EVAL_TEST.java,Java
SHORTEST_PATHS,Bug in SHORTEST PATHS implementation,java_programs/SHORTEST_PATHS.java,correct_java_programs/SHORTEST_PATHS.java,patches/SHORTEST_PATHS.patch,Standard input values,Return Value,0,3000ms,"--- java_programs/SHORTEST_PATHS.java
+++ correct_java_programs/SHORTEST_PATHS.java
@@ -1,5 +1,9 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
+import java_programs.Node;
+import java_programs.WeightedEdge;
+
 import java.lang.Math.*;
 
 /**
@@ -27,37 +31,11 @@
                         weight_by_node.get(edge.get(0))
                                 + weight_by_edge.get(edge),
                         weight_by_node.get(edge.get(1)));
-                weight_by_edge.put(edge, update_weight);
+
+                weight_by_node.put(edge.get(1), update_weight);
             }
         }
         return weight_by_node;
     }
 
-
-    /**
-     * Rewrite shortest_paths method
-     * @param node
-     * @param weight_by_edge
-     * @return
-     */
-
-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {
-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();
-        for (WeightedEdge edge : weight_by_edge) {
-                weight_by_node.put(edge.node1.toString(), INF);
-                weight_by_node.put(edge.node2.toString(), INF);
-        }
-
-        weight_by_node.put(source.getValue(), 0);
-        for (int i = 0; i < weight_by_node.size(); i++) {
-            for (WeightedEdge edge : weight_by_edge) {
-                int update_weight = Math.min(
-                        weight_by_node.get(edge.node1.toString())
-                                + edge.weight,
-                        weight_by_node.get(edge.node2.toString()));
-                edge.weight = update_weight;
-            }
-        }
-        return weight_by_node;
-    }
 }
",java_testcases/junit/SHORTEST_PATHS_TEST.java,Java
SHORTEST_PATH_LENGTH,Bug in SHORTEST PATH LENGTH implementation,java_programs/SHORTEST_PATH_LENGTH.java,correct_java_programs/SHORTEST_PATH_LENGTH.java,patches/SHORTEST_PATH_LENGTH.patch,Standard input values,Array Bounds,0,3000ms,"--- java_programs/SHORTEST_PATH_LENGTH.java
+++ correct_java_programs/SHORTEST_PATH_LENGTH.java
@@ -1,5 +1,7 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
+import java_programs.Node;
 
 /**
  *
@@ -35,7 +37,7 @@
                 }
 
                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),
-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));
+                        distance + length_by_edge.get(Arrays.asList(node, nextnode))));
             }
         }
 
",java_testcases/junit/SHORTEST_PATH_LENGTH_TEST.java,Java
SHORTEST_PATH_LENGTHS,Bug in SHORTEST PATH LENGTHS implementation,java_programs/SHORTEST_PATH_LENGTHS.java,correct_java_programs/SHORTEST_PATH_LENGTHS.java,patches/SHORTEST_PATH_LENGTHS.patch,Standard input values,Array Bounds,0,3000ms,"--- java_programs/SHORTEST_PATH_LENGTHS.java
+++ correct_java_programs/SHORTEST_PATH_LENGTHS.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 import java.lang.Math.*;
 /*
@@ -34,7 +34,8 @@
                 for (int j = 0; j < numNodes; j++) {
                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),
                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),
-                                                            length_by_path.get(Arrays.asList(j,k))));
+                                                            length_by_path.get(Arrays.asList(k,j))));
+
                     length_by_path.put(Arrays.asList(i,j), update_length);
                 }
             }
",java_testcases/junit/SHORTEST_PATH_LENGTHS_TEST.java,Java
SHUNTING_YARD,Bug in SHUNTING YARD implementation,java_programs/SHUNTING_YARD.java,correct_java_programs/SHUNTING_YARD.java,patches/SHUNTING_YARD.patch,Exception triggering inputs,Array Bounds,4,3000ms,"--- java_programs/SHUNTING_YARD.java
+++ correct_java_programs/SHUNTING_YARD.java
@@ -1,4 +1,5 @@
-package java_programs;
+package correct_java_programs;
+
 import java.util.*;
 
 /*
@@ -13,24 +14,26 @@
 public class SHUNTING_YARD {
     public static List shunting_yard(ArrayList tokens) {
         Map<String, Integer> precedence = new HashMap<String, Integer>();
-        precedence.put(""+"",1);
-        precedence.put(""-"",1);
-        precedence.put(""*"",2);
-        precedence.put(""/"",2);
+        precedence.put(""+"", 1);
+        precedence.put(""-"", 1);
+        precedence.put(""*"", 2);
+        precedence.put(""/"", 2);
 
         ArrayList rpntokens = new ArrayList(100);
         ArrayDeque opstack = new ArrayDeque();
 
-        for (Object token: tokens) {
+        for (Object token : tokens) {
             if (Integer.class.isInstance(token)) {
-            // cover also Double case I guess?
+                // cover also Double case I guess?
                 rpntokens.add((Integer) token);
             } else {
                 String operator = (String) token;
                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {
                     rpntokens.add(opstack.pop());
                 }
+                opstack.push(token);
             }
+
         }
 
         while (!opstack.isEmpty()) {
@@ -39,5 +42,5 @@
 
         return rpntokens;
     }
+}
 
-}
",java_testcases/junit/SHUNTING_YARD_TEST.java,Java
SIEVE,Bug in SIEVE implementation,java_programs/SIEVE.java,correct_java_programs/SIEVE.java,patches/SIEVE.patch,Exception triggering inputs,Array Bounds,6,3000ms,"--- java_programs/SIEVE.java
+++ correct_java_programs/SIEVE.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -38,7 +38,7 @@
     public static ArrayList<Integer> sieve(Integer max) {
         ArrayList<Integer> primes = new ArrayList<Integer>();
         for (int n=2; n<max+1; n++) {
-            if (any(list_comp(n, primes))) {
+            if (all(list_comp(n, primes))) {
                 primes.add(n);
             }
         }
",java_testcases/junit/SIEVE_TEST.java,Java
SQRT,Bug in SQRT implementation,java_programs/SQRT.java,correct_java_programs/SQRT.java,patches/SQRT.patch,Exception triggering inputs,Return Value,7,3000ms,"--- java_programs/SQRT.java
+++ correct_java_programs/SQRT.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -13,7 +13,7 @@
 public class SQRT {
     public static double sqrt(double x, double epsilon) {
         double approx = x / 2d;
-        while (Math.abs(x-approx) > epsilon) {
+        while (Math.abs(x-approx*approx) > epsilon) {
             approx = 0.5d * (approx + x / approx);
         }
         return approx;
",java_testcases/junit/SQRT_TEST.java,Java
SUBSEQUENCES,Bug in SUBSEQUENCES implementation,java_programs/SUBSEQUENCES.java,correct_java_programs/SUBSEQUENCES.java,patches/SUBSEQUENCES.patch,Exception triggering inputs,Array Bounds,12,3000ms,"--- java_programs/SUBSEQUENCES.java
+++ correct_java_programs/SUBSEQUENCES.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -13,7 +13,9 @@
 public class SUBSEQUENCES {
     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {
         if (k == 0) {
-            return new ArrayList();
+            ArrayList empty_set = new ArrayList<ArrayList>();
+            empty_set.add(new ArrayList());
+            return empty_set;
         }
 
         ArrayList ret = new ArrayList(50);
",java_testcases/junit/SUBSEQUENCES_TEST.java,Java
TOPOLOGICAL_ORDERING,Bug in TOPOLOGICAL ORDERING implementation,java_programs/TOPOLOGICAL_ORDERING.java,correct_java_programs/TOPOLOGICAL_ORDERING.java,patches/TOPOLOGICAL_ORDERING.patch,Standard input values,Array Bounds,0,3000ms,"--- java_programs/TOPOLOGICAL_ORDERING.java
+++ correct_java_programs/TOPOLOGICAL_ORDERING.java
@@ -1,5 +1,7 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
+
+import java_programs.Node;
 
 public class TOPOLOGICAL_ORDERING {
     public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {
@@ -14,7 +16,7 @@
         for (int i = 0; i < listSize; i++) {
             Node node = orderedNodes.get(i);
             for (Node nextNode : node.getSuccessors()) {
-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {
+                if (orderedNodes.containsAll(nextNode.getPredecessors()) && !orderedNodes.contains(nextNode)) {
                     orderedNodes.add(nextNode);
                     listSize++;
                 }
",java_testcases/junit/TOPOLOGICAL_ORDERING_TEST.java,Java
TO_BASE,Bug in TO BASE implementation,java_programs/TO_BASE.java,correct_java_programs/TO_BASE.java,patches/TO_BASE.patch,Exception triggering inputs,Return Value,7,3000ms,"--- java_programs/TO_BASE.java
+++ correct_java_programs/TO_BASE.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -18,7 +18,7 @@
         while (num > 0) {
             i = num % b;
             num = num / b; // floor division?
-            result = result + String.valueOf(alphabet.charAt(i));
+            result = String.valueOf(alphabet.charAt(i))+result;
         }
 
         return result;
",java_testcases/junit/TO_BASE_TEST.java,Java
WRAP,Bug in WRAP implementation,java_programs/WRAP.java,correct_java_programs/WRAP.java,patches/WRAP.patch,Exception triggering inputs,Return Value,5,3000ms,"--- java_programs/WRAP.java
+++ correct_java_programs/WRAP.java
@@ -1,4 +1,4 @@
-package java_programs;
+package correct_java_programs;
 import java.util.*;
 
 /*
@@ -28,7 +28,7 @@
             text = text.substring(end);
             lines.add(line);
         }
-
+        lines.add(text);
         return lines;
     }
 }
",java_testcases/junit/WRAP_TEST.java,Java
